#include "ssd1306_simple.h"
#include <string.h>
#include "esp_check.h"

// Minimal 5x7 font for ASCII 32..127 (we'll only implement what we need now)
static const uint8_t font5x7[][5] = {
    // ' ' (32)
    {0x00, 0x00, 0x00, 0x00, 0x00},
    // '!' (33)
    {0x00, 0x00, 0x5F, 0x00, 0x00},
    // '"' (34)
    {0x00, 0x07, 0x00, 0x07, 0x00},
    // '#' (35)
    {0x14, 0x7F, 0x14, 0x7F, 0x14},
    // '$' (36)
    {0x24, 0x2A, 0x7F, 0x2A, 0x12},
    // '%' (37)
    {0x23, 0x13, 0x08, 0x64, 0x62},
    // '&' (38)
    {0x36, 0x49, 0x55, 0x22, 0x50},
    // ''' (39)
    {0x00, 0x05, 0x03, 0x00, 0x00},
    // '(' (40)
    {0x00, 0x1C, 0x22, 0x41, 0x00},
    // ')' (41)
    {0x00, 0x41, 0x22, 0x1C, 0x00},
    // '*' (42)
    {0x14, 0x08, 0x3E, 0x08, 0x14},
    // '+' (43)
    {0x08, 0x08, 0x3E, 0x08, 0x08},
    // ',' (44)
    {0x00, 0x50, 0x30, 0x00, 0x00},
    // '-' (45)
    {0x08, 0x08, 0x08, 0x08, 0x08},
    // '.' (46)
    {0x00, 0x60, 0x60, 0x00, 0x00},
    // '/' (47)
    {0x20, 0x10, 0x08, 0x04, 0x02},
    // '0' (48)
    {0x3E, 0x51, 0x49, 0x45, 0x3E},
    // '1' (49)
    {0x00, 0x42, 0x7F, 0x40, 0x00},
    // '2' (50)
    {0x42, 0x61, 0x51, 0x49, 0x46},
    // '3' (51)
    {0x21, 0x41, 0x45, 0x4B, 0x31},
    // '4' (52)
    {0x18, 0x14, 0x12, 0x7F, 0x10},
    // '5' (53)
    {0x27, 0x45, 0x45, 0x45, 0x39},
    // '6' (54)
    {0x3C, 0x4A, 0x49, 0x49, 0x30},
    // '7' (55)
    {0x01, 0x71, 0x09, 0x05, 0x03},
    // '8' (56)
    {0x36, 0x49, 0x49, 0x49, 0x36},
    // '9' (57)
    {0x06, 0x49, 0x49, 0x29, 0x1E},
    // ':' (58)
    {0x00, 0x36, 0x36, 0x00, 0x00},
    // ';' (59)
    {0x00, 0x56, 0x36, 0x00, 0x00},
    // '<' (60) left arrow
    {0x08, 0x1C, 0x2A, 0x08, 0x08},
    // '=' (61)
    {0x14, 0x14, 0x14, 0x14, 0x14},
    // '>' (62) right arrow
    {0x08, 0x08, 0x2A, 0x1C, 0x08},
    // '?' (63)
    {0x02, 0x01, 0x51, 0x09, 0x06},
    // '@' (64)
    {0x32, 0x49, 0x79, 0x41, 0x3E},
    // 'A' (65)
    {0x7E, 0x11, 0x11, 0x11, 0x7E},
    // 'B' (66)
    {0x7F, 0x49, 0x49, 0x49, 0x36},
    // 'C' (67)
    {0x3E, 0x41, 0x41, 0x41, 0x22},
    // 'D' (68)
    {0x7F, 0x41, 0x41, 0x22, 0x1C},
    // 'E' (69)
    {0x7F, 0x49, 0x49, 0x49, 0x41},
    // 'F' (70)
    {0x7F, 0x09, 0x09, 0x09, 0x01},
    // 'G' (71)
    {0x3E, 0x41, 0x49, 0x49, 0x7A},
    // 'H' (72)
    {0x7F, 0x08, 0x08, 0x08, 0x7F},
    // 'I' (73)
    {0x00, 0x41, 0x7F, 0x41, 0x00},
    // 'J' (74)
    {0x20, 0x40, 0x41, 0x3F, 0x01},
    // 'K' (75)
    {0x7F, 0x08, 0x14, 0x22, 0x41},
    // 'L' (76)
    {0x7F, 0x40, 0x40, 0x40, 0x40},
    // 'M' (77)
    {0x7F, 0x02, 0x0C, 0x02, 0x7F},
    // 'N' (78)
    {0x7F, 0x04, 0x08, 0x10, 0x7F},
    // 'O' (79)
    {0x3E, 0x41, 0x41, 0x41, 0x3E},
    // 'P' (80)
    {0x7F, 0x09, 0x09, 0x09, 0x06},
    // 'Q' (81)
    {0x3E, 0x41, 0x51, 0x21, 0x5E},
    // 'R' (82)
    {0x7F, 0x09, 0x19, 0x29, 0x46},
    // 'S' (83)
    {0x46, 0x49, 0x49, 0x49, 0x31},
    // 'T' (84)
    {0x01, 0x01, 0x7F, 0x01, 0x01},
    // 'U' (85)
    {0x3F, 0x40, 0x40, 0x40, 0x3F},
    // 'V' (86)
    {0x1F, 0x20, 0x40, 0x20, 0x1F},
    // 'W' (87)
    {0x3F, 0x40, 0x38, 0x40, 0x3F},
    // 'X' (88)
    {0x63, 0x14, 0x08, 0x14, 0x63},
    // 'Y' (89)
    {0x07, 0x08, 0x70, 0x08, 0x07},
    // 'Z' (90)
    {0x61, 0x51, 0x49, 0x45, 0x43},
    // '[' (91)
    {0x00, 0x7F, 0x41, 0x41, 0x00},
    // '\' (92)
    {0x02, 0x04, 0x08, 0x10, 0x20},
    // ']' (93)
    {0x00, 0x41, 0x41, 0x7F, 0x00},
    // '^' (94) up arrow
    {0x04, 0x06, 0x7F, 0x06, 0x04},
    // '_' (95)
    {0x40, 0x40, 0x40, 0x40, 0x40},
    // '`' (96)
    {0x00, 0x01, 0x02, 0x04, 0x00},
    // 'a' (97)
    {0x20, 0x54, 0x54, 0x54, 0x78},
    // 'b' (98)
    {0x7F, 0x48, 0x44, 0x44, 0x38},
    // 'c' (99)
    {0x38, 0x44, 0x44, 0x44, 0x20},
    // 'd' (100)
    {0x38, 0x44, 0x44, 0x48, 0x7F},
    // 'e' (101)
    {0x38, 0x54, 0x54, 0x54, 0x18},
    // 'f' (102)
    {0x08, 0x7E, 0x09, 0x01, 0x02},
    // 'g' (103)
    {0x0C, 0x52, 0x52, 0x52, 0x3E},
    // 'h' (104)
    {0x7F, 0x08, 0x04, 0x04, 0x78},
    // 'i' (105)
    {0x00, 0x44, 0x7D, 0x40, 0x00},
    // 'j' (106)
    {0x20, 0x40, 0x44, 0x3D, 0x00},
    // 'k' (107)
    {0x7F, 0x10, 0x28, 0x44, 0x00},
    // 'l' (108)
    {0x00, 0x41, 0x7F, 0x40, 0x00},
    // 'm' (109)
    {0x7C, 0x04, 0x18, 0x04, 0x78},
    // 'n' (110)
    {0x7C, 0x08, 0x04, 0x04, 0x78},
    // 'o' (111)
    {0x38, 0x44, 0x44, 0x44, 0x38},
    // 'p' (112)
    {0x7C, 0x14, 0x14, 0x14, 0x08},
    // 'q' (113)
    {0x08, 0x14, 0x14, 0x18, 0x7C},
    // 'r' (114)
    {0x7C, 0x08, 0x04, 0x04, 0x08},
    // 's' (115)
    {0x48, 0x54, 0x54, 0x54, 0x20},
    // 't' (116)
    {0x04, 0x3F, 0x44, 0x40, 0x20},
    // 'u' (117)
    {0x3C, 0x40, 0x40, 0x20, 0x7C},
    // 'v' (118) down arrow
    {0x10, 0x30, 0x7F, 0x30, 0x10},
    // 'w' (119)
    {0x3C, 0x40, 0x30, 0x40, 0x3C},
    // 'x' (120)
    {0x44, 0x28, 0x10, 0x28, 0x44},
    // 'y' (121)
    {0x0C, 0x50, 0x50, 0x50, 0x3C},
    // 'z' (122)
    {0x44, 0x64, 0x54, 0x4C, 0x44},
    // '{' (123)
    {0x00, 0x08, 0x36, 0x41, 0x00},
    // '|' (124)
    {0x00, 0x00, 0x7F, 0x00, 0x00},
    // '}' (125)
    {0x00, 0x41, 0x36, 0x08, 0x00},
    // '~' (126)
    {0x08, 0x08, 0x2A, 0x1C, 0x08},
};

static esp_err_t ssd1306_add_device(ssd1306_t* d) {
    if (d == NULL) {
        return ESP_ERR_INVALID_ARG;
    }
    if (d->dev != NULL) {
        return ESP_OK;
    }

    i2c_device_config_t cfg = {
        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
        .device_address = d->addr,
        .scl_speed_hz = 100000,
    };
    return i2c_master_bus_add_device(d->bus, &cfg, &d->dev);
}

static esp_err_t i2c_write(ssd1306_t* d, const uint8_t* buf, size_t len) {
    ESP_RETURN_ON_ERROR(ssd1306_add_device(d), "", "");
    return i2c_master_transmit(d->dev, buf, len, 100);
}

static esp_err_t cmd(ssd1306_t* d, uint8_t c) {
    uint8_t buf[2] = {0x00, c}; // 0x00 = command stream
    return i2c_write(d, buf, sizeof(buf));
}

static esp_err_t data_bytes(ssd1306_t* d, const uint8_t* data, size_t len) {
    // 0x40 = data stream
    uint8_t header = 0x40;
    // Send control byte + payload in one I2C transaction.
    ESP_RETURN_ON_ERROR(ssd1306_add_device(d), "", "");
    i2c_master_transmit_multi_buffer_info_t xfers[] = {
        {.write_buffer = &header, .buffer_size = 1},
        {.write_buffer = data, .buffer_size = len},
    };
    return i2c_master_multi_buffer_transmit(d->dev, xfers, 2, 100);
}

esp_err_t ssd1306_init(ssd1306_t* d) {
    // SSD1306 init for 128x64, page addressing
    ESP_RETURN_ON_ERROR(ssd1306_add_device(d), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, 0xAE), "", ""); // display off
    ESP_RETURN_ON_ERROR(cmd(d, 0xD5), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, 0x80), "", ""); // clock
    ESP_RETURN_ON_ERROR(cmd(d, 0xA8), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, 0x3F), "", ""); // multiplex 64-1
    ESP_RETURN_ON_ERROR(cmd(d, 0xD3), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, 0x00), "", ""); // display offset
    ESP_RETURN_ON_ERROR(cmd(d, 0x40), "", ""); // start line
    ESP_RETURN_ON_ERROR(cmd(d, 0x8D), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, 0x14), "", ""); // charge pump on
    ESP_RETURN_ON_ERROR(cmd(d, 0x20), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, 0x02), "", ""); // page addressing mode
    ESP_RETURN_ON_ERROR(cmd(d, 0xA1), "", ""); // segment remap
    ESP_RETURN_ON_ERROR(cmd(d, 0xC8), "", ""); // COM scan dec
    ESP_RETURN_ON_ERROR(cmd(d, 0xDA), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, 0x12), "", ""); // com pins
    ESP_RETURN_ON_ERROR(cmd(d, 0x81), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, 0xCF), "", ""); // contrast
    ESP_RETURN_ON_ERROR(cmd(d, 0xD9), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, 0xF1), "", ""); // precharge
    ESP_RETURN_ON_ERROR(cmd(d, 0xDB), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, 0x40), "", ""); // vcom detect
    ESP_RETURN_ON_ERROR(cmd(d, 0xA4), "", ""); // resume RAM
    ESP_RETURN_ON_ERROR(cmd(d, 0xA6), "", ""); // normal display
    ESP_RETURN_ON_ERROR(cmd(d, 0xAF), "", ""); // display on
    return ESP_OK;
}

esp_err_t ssd1306_set_cursor(ssd1306_t* d, uint8_t page, uint8_t col) {
    ESP_RETURN_ON_ERROR(cmd(d, (uint8_t)(0xB0 | (page & 0x07))), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, (uint8_t)(0x00 | (col & 0x0F))), "", "");
    ESP_RETURN_ON_ERROR(cmd(d, (uint8_t)(0x10 | ((col >> 4) & 0x0F))), "", "");
    return ESP_OK;
}

esp_err_t ssd1306_clear(ssd1306_t* d) {
    uint8_t zero[128];
    memset(zero, 0x00, sizeof(zero));
    for (uint8_t page = 0; page < 8; page++) {
        ESP_RETURN_ON_ERROR(ssd1306_set_cursor(d, page, 0), "", "");
        ESP_RETURN_ON_ERROR(data_bytes(d, zero, sizeof(zero)), "", "");
    }
    return ESP_OK;
}

esp_err_t ssd1306_write_text_5x7(ssd1306_t* d, const char* text) {
    // Writes on current page/col. Each char = 5 columns + 1 blank column.
    while (*text) {
        char c = *text++;
        if (c < 32 || c > 126)
            c = '?';
        const uint8_t* glyph;
        if (c == '?') {
            static const uint8_t q[5] = {0x02, 0x01, 0x51, 0x09, 0x06};
            glyph = q;
        } else {
            glyph = font5x7[(int)(c - 32)];
        }
        uint8_t buf[6];
        buf[0] = glyph[0];
        buf[1] = glyph[1];
        buf[2] = glyph[2];
        buf[3] = glyph[3];
        buf[4] = glyph[4];
        buf[5] = 0x00;
        ESP_RETURN_ON_ERROR(data_bytes(d, buf, sizeof(buf)), "", "");
    }
    return ESP_OK;
}
